-- 1. Zmodyfikuj strukturę relacji PROJEKTY, dodając do niej definicje następujących
ograniczeń integralnościowych (użyj kilku poleceń):
 klucz podstawowy o nazwie PK_PROJEKTY na atrybucie ID_PROJEKTU,
 klucz unikalny o nazwie UK_PROJEKTY na atrybucie OPIS_PROJEKTU,
 atrybut OPIS_PROJEKTU nie przyjmuje wartości pustych,
 wartość atrybutu DATA_ZAKONCZENIA musi być późniejsza niż wartość atrybutu
DATA_ROZPOCZECIA,
 atrybut FUNDUSZ akceptuje tylko wartości dodatnie lub wartości puste. 
ALTER TABLE PROJEKTY ADD CONSTRAINT PK_PROJEKTY PRIMARY KEY (ID_PROJEKTU);
ALTER TABLE PROJEKTY ADD CONSTRAINT UK_PROJEKTY UNIQUE (OPIS_PROJEKTU);
ALTER TABLE PROJEKTY MODIFY OPIS_PROJEKTU NOT NULL;
ALTER TABLE PROJEKTY ADD CONSTRAINT CHK_DATES CHECK (DATA_ZAKONCZENIA > DATA_ROZPOCZECIA);
ALTER TABLE PROJEKTY ADD CONSTRAINT CHK_FUNDUSZ CHECK (FUNDUSZ > 0 OR FUNDUSZ IS NULL);
SELECT *
FROM user_constraints
WHERE table_name = 'PROJEKTY';

--  2. Spróbuj wstawić do relacji PROJEKTY rekord, który zduplikuje opis istniejącego już
projektu „Indeksy bitmapowe”
INSERT INTO PROJEKTY (OPIS_PROJEKTU, DATA_ROZPOCZECIA, DATA_ZAKONCZENIA, FUNDUSZ)
VALUES ('INDEKSY BITMAPOWE', '2015-04-12', '2016-09-30', 40000)
NIE MOZNA BO OPIS_PROJEKTU TO KLUCZ UNIKALNY WIEC NIE MOZNA DUBLOWAC WARTOSCI

-- 3. Utwórz relację o nazwie PRZYDZIALY o następującej strukturze:
CREATE TABLE PRZYDZIALY (
    ID_PROJEKTU NUMBER(4) NOT NULL CONSTRAINT FK_PRZYDZIALY_01 REFERENCES PROJEKTY(ID_PROJEKTU),
    NR_PRACOWNIKA NUMBER(6) NOT NULL CONSTRAINT FK_PRZYDZIALY_02 REFERENCES PRACOWNICY(ID_PRAC),
    PRZYDZIAL_OD DATE DEFAULT SYSDATE,
    PRZYDZIAL_DO DATE,
    STAWKA NUMBER(7,2) CONSTRAINT CHK_PRZYDZIALY_STAWKA CHECK(STAWKA > 0),
    ROLA VARCHAR2(20) CONSTRAINT CHK_PRZYDZIALY_ROLA CHECK(ROLA IN ('ANALITYK', 'KIERUJĄCY', 'PROGRAMISTA')),
    CONSTRAINT PK_PRZYDZIALY PRIMARY KEY (ID_PROJEKTU, NR_PRACOWNIKA),
    CONSTRAINT CHK_PRZYDZIALY_DATY CHECK(PRZYDZIAL_DO > PRZYDZIAL_OD)
);

-- 4. Wstaw do relacji PRZYDZIALY trzy rekordy:
INSERT INTO PRZYDZIALY (ID_PROJEKTU, NR_PRACOWNIKA, PRZYDZIAL_OD, PRZYDZIAL_DO, STAWKA, ROLA)
VALUES ((SELECT ID_PROJEKTU FROM PROJEKTY WHERE OPIS_PROJEKTU = 'INDEKSY BITMAPOWE'), 170, '1999-04-10', '1999-05-10', 1000, 'KIERUJĄCY');
INSERT INTO PRZYDZIALY (ID_PROJEKTU, NR_PRACOWNIKA, PRZYDZIAL_OD, PRZYDZIAL_DO, STAWKA, ROLA)
VALUES ((SELECT ID_PROJEKTU FROM PROJEKTY WHERE OPIS_PROJEKTU = 'Indeksy bitmapowe'), 140,
    TO_DATE('01-12-2000', 'DD-MM-YYYY'),
    NULL, -- PRZYDZIAL_DO nie jest podany
    1500,
    'ANALITYK'
);

INSERT INTO PRZYDZIALY (ID_PROJEKTU, NR_PRACOWNIKA, PRZYDZIAL_OD, PRZYDZIAL_DO, STAWKA, ROLA)
VALUES (
    (SELECT ID_PROJEKTU FROM PROJEKTY WHERE OPIS_PROJEKTU = 'Sieci kręgosłupowe'), -- Pobiera ID projektu
    140,
    TO_DATE('14-09-2015', 'DD-MM-YYYY'),
    NULL, -- PRZYDZIAL_DO nie jest podany
    2500,
    'KIERUJĄCY'
);

-- 5. Dodaj do relacji PRZYDZIALY atrybut GODZINY, będący liczbą całkowitą o
maksymalnej wartości równej 9999. Atrybut nie może przyjmować wartości pustych.
ALTER TABLE PRZYDZIALY ADD GODZINY NUMBER(4,0) NOT NULL CONSTRAINT CHK_GODZINY CHECK (GODZINY>0)
W SKROCIE W MOMENCIE DODAWANIE TEJ KOLUMNY WYMAGAM BY BYLA ONA NOT NULL NIE PUSTA ALE JEST PUSTA BO DOPIERO JA DODAJE BEZ DANYCH WIEC ROZWIAZANIE DODAJE JA WTEDY COS TAM WSTAWIAM JUZ JEST NIE PUSTA I DOPIERO POTEM ALTER TABLE NOT NULL 

-- 6. Operację z poprzedniego punktu wykonaj w następujący sposób:
 dodaj definicję atrybutu GODZINY bez wskazania wymagalności wartości,
 ustaw wartości atrybutu GODZINY w poszczególnych rekordach relacji PRZYDZIALY
na wybrane przez siebie wartości,
 nałóż na atrybut GODZINY wymagalność wartości. 
ALTER TABLE PRZYDZIALY ADD GODZINY NUMBER(4,0) CONSTRAINT CHK_GODZINY CHECK (GODZINY>=0);
UPDATE PRZYDZIALY 
SET GODZINY = 100;
ALTER TABLE PRZYDZIALY MODIFY GODZINY NOT NULL;

-- 7. Wykonaj tylko jeśli pracujesz w OracleDB: wyłącz (nie usuwaj!) sprawdzanie unikalności
opisów projektów w relacji PROJEKTY. 
ALTER TABLE PROJEKTY DISABLE CONSTRAINT UK_PROJEKTY;
SELECT CONSTRAINT_NAME, STATUS FROM USER_CONSTRAINTS WHERE CONSTRAINT_NAME = 'UK_PROJEKTY';


-- 8. Wykonaj tylko jeśli pracujesz w OracleDB: wstaw do relacji PROJEKTY rekord, który
zduplikuje opis istniejącego już projektu „Indeksy bitmapowe”. 
INSERT INTO PROJEKTY (OPIS_PROJEKTU, DATA_ROZPOCZECIA, DATA_ZAKONCZENIA, FUNDUSZ)
VALUES ('Indeksy bitmapowe', DATE '2015-04-12', DATE '2016-09-30', 40000);
I TERAZ MOZNA WSTAWIC O TAKIM SAMYM OPISIE BO WCZESNIEJ WYLACZYLISMY TEN KLUCZ JAKBY ON DALEJ TAM JEST ALE NIE DZIALA DOPOKI NIE WLACZYMY

-- 9. Wykonaj tylko jeśli pracujesz w OracleDB: spróbuj włączyć wyłączone przed chwilą
ograniczenie. 
ALTER TABLE PROJEKTY
ENABLE CONSTRAINT UK_PROJEKTY;
NIE MOZNA BO TERAZ W OPISACH PROJEKTU MAMY DWA TAKIE SAME REKORDY TRZEBA PIERW ZAPEWNIC UNIKANOSC DANYCH ZEBY DOPIERO POTEM WLACZYC OGRANICZENIE

-- 10. Wykonaj tylko jeśli pracujesz w OracleDB: zmień opis dodanego przed chwilą projektu z
„Indeksy bitmapowe” na „Inne indeksy” (zwróć uwagę, że teraz w relacji PROJEKTY
mamy dwa projekty z opisem „Indeksy bitmapowe” – masz zmienić opis tylko jednego,
dodanego przed chwilą). Następnie spróbuj ponownie włączyć wyłączone ograniczenie. 
UPDATE PROJEKTY SET OPIS_PROJEKTU = 'Inne indeksy'
WHERE ID_PROJEKTU = 41;
ALTER TABLE PROJEKTY
ENABLE CONSTRAINT UK_PROJEKTY;
I TERAZ MOZNA BO DANE W OPIS_PROJEKTU SA UNIKALNE

-- 11. Spróbuj zmienić maksymalny rozmiar atrybutu OPIS_PROJEKTU w relacji PROJEKTY
na 10 znaków. 
ALTER TABLE PROJEKTY MODIFY OPIS_PROJEKTU VARCHAR2(10);
NIE MOZNA BO W TABELI PROJEKTY JEST JAKAS DANE OPIS_PROJEKTU DLUZSZA NIZ 10 ZNAKOW

-- 12. Spróbuj usunąć z relacji PROJEKTY rekord opisujący projekt z opisem „Sieci
kręgosłupowe”. 
DELETE FROM PROJEKTY WHERE OPIS_PROJEKTU = 'SIECI KREGOSLUPOWE';
NIE MOZNA BO ID_PROJEKTU JEST KLUCZEM OBCYM W TABELI PRZYDZIALY WIEC WYSTEPUJE W INNEJ TABELI DLATEGO NIE MOZNA. TRZEBA BY PIERW TO ODNIESENIE PEWNIE USUNAC ALBO USUNAC KLUCZ OBCY

-- 13 Zmień w relacji PRZYDZIALY definicję klucza obcego o nazwie FK_PRZYDZIALY_01 w
taki sposób, aby usunięcie projektu z relacji PROJEKTY automatycznie powodowało
usunięcie związanych z usuwanym projektem przydziałów z relacji PRZYDZIALY
(wykonaj to przy pomocy dwóch poleceń ALTER TABLE).
ALTER TABLE PRZYDZIALY DROP CONSTRAINT FK_PRZYDZIALY_01;
ALTER TABLE PRZYDZIALY ADD CONSTRAINT FK_PRZYDZIALY_01 FOREIGN KEY (ID_PROJEKTU) REFERENCES PROJEKTY(ID_PROJEKTU) ON DELETE CASCADE;
TERAZ W PRZYPADKU USUNIECIA USUWA DANE DOTYCZACE DANEGO ID_PROJEKTU Z TABELI PROJEKTY TYLKO DANE NIE KOLUMNE

-- 14. 4. Sprawdź w słowniku bazy danych, jakie ograniczenia integralnościowe aktualnie są
zdefiniowane w relacji PRZYDZIAŁY.
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, SEARCH_CONDITION, R_CONSTRAINT_NAME, STATUS
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'PRZYDZIALY';

-- 15. Spróbuj usunąć relację PROJEKTY. Użyj polecenia, które jednocześnie z usuwaną relacją
usunie klucze obce z innych relacji, wskazujące na usuwaną relację. 
DROP TABLE PROJEKTY CASCADE CONSTRAINTS;

-- 16. Usuń pozostałe dwie relacje: PRZYDZIALY i PROJEKTY_KOPIA. 
DROP TABLE PRZYDZIALY;
DROP TABLE PROJEKTY_KOPIA;
SELECT TABLE_NAME FROM USER_TABLES;
